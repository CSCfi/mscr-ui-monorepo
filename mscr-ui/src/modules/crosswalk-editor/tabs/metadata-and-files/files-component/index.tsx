import { NodeMapping } from '@app/common/interfaces/crosswalk-connection.interface';
import {useEffect, useMemo, useState} from 'react';
import * as React from 'react';
import router from 'next/router';
import {FilesRow} from '@app/common/interfaces/crosswalk.interface';
import GenericTable from '@app/common/components/generic-table';
import { getDatamodelApiBaseQuery } from '@app/store/api-base-query';


export enum DownloadType {
  'CROSSWALK',
  'GENERATED_SCHEMA',
  'ORIGINAL_CROSSWALK',
  'ORIGINAL_SCHEMA',
}

const BASEURL = process.env.DATAMODEL_API_URL
  ? `${process.env.DATAMODEL_API_URL}/v2`
  : 'http://localhost:9004/datamodel-api/v2';


export default function FilesComponent(props: {
  crosswalkData: any;
  isAdmin: boolean;
}) {

  const lang = router.locale ?? 'en';
  const [autoGeneratedFilesTable, setAutoGeneratedFilesTable] =
    useState<FilesRow[]>([]);

  const [uploadedFilesTable, setUploadedFilesTable] =
    useState<FilesRow[]>([]);


  useEffect(() => {
    generateFilesData(props.crosswalkData);
  }, [props.crosswalkData]);


  function generateDownloadUrl(filePid: string, fileType: DownloadType) {
    switch(fileType) {
    case DownloadType.CROSSWALK: {
      return BASEURL + '/crosswalk/' + filePid + '/mapping';
    }
    case DownloadType.GENERATED_SCHEMA: {
      return BASEURL + '/schema/' + filePid + '/internal';
    }
    case DownloadType.ORIGINAL_CROSSWALK: {
      return BASEURL + '/crosswalk/' + filePid + '/original';
    }
    case DownloadType.ORIGINAL_SCHEMA: {
      return BASEURL + '/schema/' + filePid + '/original';
    }
    default: {
      return '';
    }
    }
  }

  function generateDownloadLink(url: string){
    return (<a href={url} target='_blank' rel='noreferrer'>Download</a>);
  }

  function generateFilesData(crosswalkData: any) {
    const autoGeneratedTable: FilesRow[] = [];
    const uploadedFilesTable: FilesRow[] = [];
    if (crosswalkData?.format) {
      if (crosswalkData.format === 'MSCR') {
        autoGeneratedTable.push({
          name: crosswalkData?.label[lang] ? crosswalkData?.label[lang] : '',
          added: crosswalkData?.created ? crosswalkData.created : '',
          format: 'MSCR',
          file: crosswalkData?.pid ? generateDownloadLink(generateDownloadUrl(crosswalkData?.pid, DownloadType.CROSSWALK)) : '',
        });
      }
      setAutoGeneratedFilesTable(autoGeneratedTable);
    }

    if (crosswalkData?.format && crosswalkData.format !== 'MSCR') {
      let filesMetadata = [];
      filesMetadata = crosswalkData.fileMetadata;

      //TODO: replace slice function with correct implementation
      filesMetadata.forEach((item: any) => {
        uploadedFilesTable.push({
          name: item?.filename,
          added: crosswalkData?.modified ? crosswalkData?.modified : '',
          format: crosswalkData?.format ? crosswalkData?.format : '',
          file: item?.filename
            ? generateDownloadLink(
              generateDownloadUrl(
                item?.filename.slice(0, -4),
                DownloadType.ORIGINAL_CROSSWALK,
              ),
            )
            : '',
        });
      });
      /*      uploadedFilesTable.push({
        name: 'Original source schema file',
        added: crosswalkData?.modified ? crosswalkData?.modified : '',
        format: 'N/A',
        file: crosswalkData?.pid ? generateDownloadLink(generateDownloadUrl(crosswalkData?.pid + '_schema.json', DownloadType.GENERATED_SCHEMA)) : '',
      });*/

      setUploadedFilesTable(uploadedFilesTable);
    }
  }

  return (
    <>
      <div className="crosswalk-editor metadata-and-files-wrap mx-2">
        {autoGeneratedFilesTable.length > 0 &&
              <GenericTable items={autoGeneratedFilesTable} headings={[]} caption={'Auto-generated files'}></GenericTable>
        }
        <br/>
        {uploadedFilesTable.length > 0 &&
              <GenericTable items={uploadedFilesTable} headings={[]} caption={'Uploaded files'}></GenericTable>
        }
        <br />
      </div>
    </>
  );
}

import { useTranslation } from 'next-i18next';
import GenericTable from '@app/common/components/generic-table';
import * as React from 'react';
import {FilesRowInput, SchemaFileData} from '@app/common/interfaces/schema.interface';
import {FilesRow} from '@app/common/interfaces/crosswalk.interface';
import {DownloadType} from '@app/modules/crosswalk-editor/tabs/metadata-and-files/files-component';
import {useEffect, useState} from 'react';
import router from 'next/router';

enum DownloadTypes {
  'CROSSWALK',
  'GENERATED_SCHEMA',
  'ORIGINAL_CROSSWALK',
  'ORIGINAL_SCHEMA',
  'SCHEMA'
}

export type DownloadNewz =
  | 'CROSSWALK'
  | 'GENERATED_SCHEMA'
  | 'ORIGINAL_CROSSWALK'
  | 'ORIGINAL_SCHEMA';

const BASEURL = process.env.DATAMODEL_API_URL
  ? `${process.env.DATAMODEL_API_URL}/v2`
  : '/datamodel-api/v2';

export default function MetadataFilesTable({
  filesRowInput, crosswalkData,
  canEdit
}: {
  filesRowInput?: SchemaFileData[] | undefined;
  crosswalkData?: any | undefined;
  canEdit: boolean;
}) {
  const { t } = useTranslation('common');
  const lang = router.locale ?? 'en';

  const [autoGeneratedFilesTable, setAutoGeneratedFilesTable] = useState<
    FilesRow[]
    >([]);

  useEffect(() => {
    generateFilesData(crosswalkData);
  }, [crosswalkData]);

  const [uploadedFilesTable, setUploadedFilesTable] = useState<FilesRow[]>([]);

  function generateDownloadUrl(fileType: DownloadTypes, pid: string, fileId?: string) {
    switch (fileType) {
      case DownloadTypes.CROSSWALK: {
        return BASEURL + '/crosswalk/' + pid + '/mapping';
      }
      case DownloadTypes.GENERATED_SCHEMA: {
        return BASEURL + '/schema/' + pid + '/internal';
      }
      case DownloadTypes.ORIGINAL_CROSSWALK: {
        return BASEURL + '/crosswalk/' + pid + '/original';
      }
      case DownloadTypes.ORIGINAL_SCHEMA: {
        return BASEURL + '/schema/' + pid + '/original';
      }
      case DownloadTypes.SCHEMA: {
        return BASEURL + '/schema/' + pid + + '/files/' + fileId + '?download=true';
      }
      default: {
        return '';
      }
    }
  }

  function generateDownloadLink(url: string) {
    return (
      <a href={url} target="_blank" rel="noreferrer">
        Download
      </a>
    );
  }


  async function getData2(pid: string, fileId: string) {
    const res = await fetch(
      '/datamodel-api/v2/frontend/schema/' + pid + '/files/' + fileId + '?download=true'
    );
    if (!res.ok) {
      throw new Error('Failed to fetch data');
    }
    return res.json();
  }

  function generateFilesData(crosswalkData: any) {
    //console.log('daattaa', getData2());
    const autoGeneratedTable: FilesRow[] = [];
    const uploadedFilesTable: FilesRow[] = [];
    console.log('crosswalkData', crosswalkData);
    if (crosswalkData?.format) {
      if (crosswalkData.format === 'MSCR') {
        autoGeneratedTable.push({
          name: crosswalkData?.label[lang] ? crosswalkData?.label[lang] : '',
          added: crosswalkData?.created ? crosswalkData.created : '',
          format: 'MSCR',
          file: crosswalkData?.pid
            ? generateDownloadLink(
              generateDownloadUrl(crosswalkData?.pid, DownloadTypes.CROSSWALK),
            )
            : '',
        });
      }
      setAutoGeneratedFilesTable(autoGeneratedTable);
    }


    if (crosswalkData?.format && crosswalkData.format !== 'MSCR') {
      let filesMetadata = [];
      filesMetadata = crosswalkData.fileMetadata;

      //TODO: replace slice function with correct implementation
      filesMetadata.forEach((item: any) => {
        uploadedFilesTable.push({
          name: item?.filename,
          added: crosswalkData?.modified ? crosswalkData?.modified : '',
          format: crosswalkData?.format ? crosswalkData?.format : '',
          file: item?.filename
            ? generateDownloadLink(
              generateDownloadUrl(
                DownloadTypes.ORIGINAL_CROSSWALK,
                item?.filename.slice(0, -4),
              ),
            )
            : '',
        });
      });
      /*      uploadedFilesTable.push({
        name: 'Original source schema file',
        added: crosswalkData?.modified ? crosswalkData?.modified : '',
        format: 'N/A',
        file: crosswalkData?.pid ? generateDownloadLink(generateDownloadUrl(crosswalkData?.pid + '_schema.json', DownloadType.GENERATED_SCHEMA)) : '',
      });*/

      setUploadedFilesTable(uploadedFilesTable);
    }
  }

  let tableRows;
  if (filesRowInput) {
    tableRows = filesRowInput.map(
      (item: { filename: any; fileID: any; contentType: any; size: any }) => {
        const test = {
          filename: item.filename,
          format: item.contentType,
          size: item.size,
          downloadLink: generateDownloadLink(
            generateDownloadUrl(DownloadTypes.ORIGINAL_SCHEMA, item.filename, item.fileID),
          ),
        };
        return test;
      },
    );
  }

  return (
    <>
      <div className="crosswalk-editor metadata-and-files-wrap mx-2">
        {filesRowInput && filesRowInput.length > 0 && (
          <GenericTable
            items={tableRows}
            headings={[
              t('metadata.file.name'),
              t('metadata.file.format'),
              t('metadata.file.size'),
              'Download',
            ]}
            caption={t('metadata.file.label')}
          ></GenericTable>
        )}
        {autoGeneratedFilesTable.length > 0 && (
          <GenericTable
          items={autoGeneratedFilesTable}
          headings={[]}
          caption={'Auto-generated files'}
          ></GenericTable>
          )}
          <br />
        {uploadedFilesTable.length > 0 && (
          <GenericTable
          items={uploadedFilesTable}
          headings={[]}
          caption={'Uploaded files'}
          ></GenericTable>
          )}

        <br />
      </div>
    </>
  );
}
